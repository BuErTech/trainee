## 6.7.阻尼牛顿法
- 1.引入
        - ![](https://img2018.cnblogs.com/blog/1780252/201908/1780252-20190829000129448-876950498.png)
- 2.推导
        - ![](https://img2018.cnblogs.com/blog/1780252/201908/1780252-20190829000201422-1593693378.png)

- 3.python实现：
```python

from linear_search.wolfe import *
from linear_search.Function import *
from numpy import *

# 阻尼牛顿法
def newton(f, start):
    fun = Function(f)
    x = array(start)
    g = fun.grad(x)
    while fun.norm(x) > 0.01:
        G = fun.hesse(x)
        d = (-dot(linalg.inv(G), g)).tolist()[0]
        alpha = wolfe(f, x, d)
        x = x + alpha * array(d)
        g = fun.grad(x)
    return x

```

## 6.8.拟牛顿法

- 1.概述：
![](https://img2018.cnblogs.com/blog/1780252/201908/1780252-20190828235930454-1474810144.png)

- 2.推导
![](https://img2018.cnblogs.com/blog/1780252/201908/1780252-20190829000011962-1523853994.png)

- 3.python实现：
```python

# coding=utf-8
from linear_search.wolfe import *
from linear_search.Function import *
from numpy import *


# 拟牛顿法
def simu_newton(f, start):
    n=size(start)
    fun = Function(f)
    x = array(start)
    g = fun.grad(x)
    B=eye(n)
    while fun.norm(x) > 0.01:
        d = (-dot(linalg.inv(B), g)).tolist()
        alpha = wolfe(f, x, d)
        x_d=array([alpha * array(d)])
        x = x + alpha * array(d)
        g_d=array([fun.grad(x)-g])
        g = fun.grad(x)
        B_d=dot(B,x_d.T)
        B=B+dot(g_d.T,g_d)/dot(g_d,x_d.T)-dot(B_d,B_d.T)/dot(x_d,B_d)
    return x

```